# 스트림 프로세싱

* 카프카는 이벤트 스트림을 전달할 수 있는 강력한 메시지 버스

## 스트림 프로세싱이란?

* 이벤트 스트림은 무한 데이터 셋을 나타내는 추상 개념, 끊임 없이 데이터가 전달됨
* 다양한 업무 활동에서 이벤트 스트림은 나타남(주식 거래, 택배, 신용카드 거래 등등)

### 이벤트 스트림에는 순서가 있다

* 이벤트는 다른 이벤트 전이나 후에 발생한다.
* 이벤트 스트림과 관계형 데이터베이스가 다른점은 관계형 데이터베이스는 레코드에 순서가 없다고 간주함

### 불변 데이터 레코드

* 이벤트 자체는 일단 발생하면 변경될 수 없음
* 관계형 데이터베이스와 다른점은 이벤트 스트림에는 스트림 자체에 모든 트랜잭션이 수록

### 이벤트 스트림은 재생 가능할 수 있다

* 에러 수정, 새로운 분석 방법 시도, 데이터 검토 등을 위해 재생 가능해야 한다.
* 이벤트 스트림은 캡쳐하고 재생할 수 있다.

## 스트림 프로세싱이란?

* 스트림 프로세싱은 하나 이상의 이벤트 스트림을 처리하는 것을 나타냄
* 스트림 프로세싱은 요청-응답, 배치 처럼 프로그래밍 패러다임중 하나이다.

### 요청-응답

* 애플리케이션이 요청을 전송한 후 프로세싱 스시템의 응답을 기다리는 형태

### 배치 프로세싱

* 지연은 많지만 처리량이 높은 형태
* 시스템이 설정한 시간에 동작
* 효율성이 크고 대량의 데이터를 일괄 처리 할 수 있음

### 스트림 프로세싱

* 연속적이고 중단되지 않는 패러다임
* 요청-응답과 배치 프로세싱간의 격차를 줄여줌
* 지속적이지만 중단되지 않는 프로세싱에 적합

## 스트림 프로세싱의 개념

* 스트림 프로세싱은 데이터를 읽고 처리한 후 결과를 저장하는 유형의 데이터 프로세싱과도 유사
* 그러나 스트림 프로세싱에만 있는 고유한 핵심 개념들이 있음

### 시간

* 대부분의 스트림 프로세싱 작업은 타임 윈도우 작업으로 수행

#### 이벤트 시간

* 추적하는 이벤트가 발생하여 레코드가 생성된 시간
* 이벤트 시간은 스트림 데이터를 처리할 때 가장 중요한 시간이다.

#### 로그 추가 시간

* 이벤트가 카프카 브로커에 전송되어 자장된 시간
* 레코드가 생성된 후에는 이 시간이 변경되지 않는다.

#### 처리 시간

* 스트림 프로세싱 애플리케이션이 처리를 수행하기 위해 이벤트를 받은 시간
* 같은 애플리케이션의 다른 스레드에서도 다를 수 있기 때문에 신뢰성이 매우 낮은 시간 개념

### 상태

* 이벤트 간에 저장되는 정보를 상태라고 함
* 스트림 프로세싱에는 몇가지 유형의 상태가 있음

#### 로컬 또는 내부 상태

* 스트림 프로세싱 애플리케이션의 특정 인스턴에서만 사용할 수 있는 상태
* 애플리케이션 내부에 포함되어 메모리에서 실행
* 속도가 빠름
* 메모리 제한이 있음

#### 외부 상태

* 다른 시스템에 저장되고 유지 관리되는 상태
* 크기 제한이 없음
* 스트림 프로세싱 애플리케이션의 여러 인스턴스 또는 다른 애플리케이션에서도 사용 가능
* 지연이 있을 수 있음 


### 스트림과 테이블의 이원성

* 스트림은 변경 사항의 이력을 포함
* 스트림을 테이블로 변환하는 것을 스트림의 구체화라고 한다.

### 타임 윈도우

* 대부분의 스트림 작업은 타임 윈도우 작업으로 수행
* 타임 윈도우 크기에 따라 지연이 결정 됨
* 스트림따라 진행하는 간격이 타임 윈도우와 같다면 텀블링 윈도우, 다를 경우 호핑 윈도우라고 한다.

## 스트림 프로세싱 디자인 패턴

### 단일 이벤트 프로세싱

* 각 이벤트를 별개로 처리하는 방법
* 스트림으로부터 이벤트들을 읽고 변경한 후 다른 스트림으로 쓴다.

### 로컬 상태를 사용한 스트림 프로세싱

* 정보의 집계에 관심을 두는 경우가 많음
* 집계 하려는 데이터를 공유 상태가 아닌 로컬 상태에서 사용
* 메모리 사용과 영속성, 리밸런싱에 대한 고려가 필요하다.

### 다단계 프로세싱과 집계 파티션 생성

* 흩어져 있는 인스턴스 데이터를 하나의 파티션으로 모아서 접근하는 다단계 접근법을 사용

### 외부 데이터 검색을 사용하는 스트림 프로세싱: 스트림과 테이블 조인

* 스트림 프로세싱에서 외부 데이터를 스트림과 조인 해야 할 수도 있음
* 이 패턴에서는 외부 데이터 검색으로 인해 지연이 발생할 수 있음 
* 그렇기 때문에 외부 데이터베이스로부터 받은 정보를 캐싱해야 함
* 카프카 커넥터를 사용해 외부 데이터베이스 변경에 대한 부분을 캐시를 변경할 수 있음

### 스트리밍 조인

* 두 개의 실제 이벤트 스트림을 조인
* 두 스트림에서 같은 키와 같은 타임 우니도우를 갖은 이벤트들이 있으면 일치 시킴
* 그렇기 때문에 윈도우 조인이라고도 함

### 비순서적 이벤트

* 잘못된 시간에 스트림에 도달한 이벤트를 처리해야 하는 경우도 있음
* 프로세싱 시간과는 별개로 이벤트 시간의 개념을 사용

### 다시 프로세싱하기

### 토폴로지

* 토폴로지는 모든 이벤트가 입력에서 출력으로 이행하는 동안 수행되는 작업과 변환 처리의 집합
* 토폴로지는 항상 하나 이상의 소스 프로세서로 시작해서 하나 이상의 싱크 프로세서로 끝난다.

### 토폴로지 규모 확장

* 토폴로지 실행을 태스크로 분할
* 태스크 개수는 애플리케이션이 처리하는 토픽의 파티션 개수
* 리파티션이 필요할 때는 토폴로지가 두개의 서브 토폴로지로 나뉘며, 각각 별개의 태스크로 처리된다.
* 장점은 리파티션 된 토폴로지 태스크는 이전 태스크와 의존성이 없다.
=======
# 카프카 모니터링
* 메트릭 : 성능이나 상태를 모니터링하기 위한 측정 지표

# 카프카 브로커 메트릭

## 미복제 파티션
* 클러스터의 각 브로커가 제공하는 이 메트릭은 리더 리플리카 브로커의 파티션을 팔로어 리플리카 브로커들이 복제하지 못한 파티션들의 총계를 제공한다.
* 값의 범위 : 0 이상의 정수
* 0이 아닌 숫자가 꾸준히 나타날 때는 클러스터의 브로커 중 하나가 오프라인 상태라는 것을 나타냄
* 미복제 파티션의 수가 변동되거나 오프라인 상태의 브로커가 하나도 없다면 클러스터 성능 문제
* 특정 브로커가 공통으로 나타나는지 살펴봐야 함

### 클러스터 수준의 문제
* 둘 중 하나의 문제, **부하 불균형**, **자원 고갈**
* 부하 불균형이라면 아래 메트릭을 통해 균형을 확인해야 한다.
  * 파티션 개수
  * 리더 파티션 개수
  * 모든 토픽의 메시지/바이트 입력 처리 속도
  * 모든 토픽의 바이트 출력 처리 속도
* 이것을 해결하려면 브로커의 파티션을 부하가 적은 브로커로 재할당 해야 한다.
* 클러스터 성능 문제일 경우 대부분 리소스 요인이 많음

### 호스트 수준의 문제
* 호스트의 하드웨어 장애나 구성의 차이 떄문에 발생할 수 있음

---

## 브로커 메트릭
### 엑티브 컨트롤러 수치
* 액티브 컨트롤러 수치 메트릭은 해당 브로커가 클러스터의 컨트롤러인지를 나타낸다.
* 반드시 하나의 컨트롤러만 있어야 한다.
* 값의 범위는 0 또는 1

### 요청 핸들러 유휴 비율
* 요청 핸들러(디스크 메시지를 읽거나, 클라이언트에 요청하는 책임을 가짐)의 작업량을 나타냄
* 사용중이 아닌 시간을 백분율로 표시
* 숫자가 작을 수록 브로커의 작업 부담이 커짐
* 스레드 풀의 수를 늘리거나 스레드가 불필요한 작업을 하는지 확인 필요

### 모든 토픽의 바이트 입력
* 브로커가 프로듀서 클라이언트로부터 받는 메시지 트래픽이 얼마인지 측정하는데 유용
* 클러스터 확장, 데이터 증가에 따른 작업 시기를 결정하는데 유용

### 모든 토픽의 바이트 출력
* 출력 속도는 컨슈머가 메시지를 읽는 속도를 보여준다.

### 모든 토픽의 메시지 입력
* 입력 속도는 메시지 크기와 무관하게 초당 입력되는 개별적인 메시지 수를 나타냄

### 오프라인 파티션
* 클러스터에서 현재 리더가 없는 파티션 개수를 나타냄
* 리더가 없는 파티션은 다음 두 가지 이유로 나타남
  * 해당 파티션의 리더나 팔로어인 모든 브로커들이 다운
  * 해당 파티션의 메시지 개수 불일치로 리더가 될수 있는 동기화 리플리카가 없고, 언클린 리더 순출이 불가능할 경우

---

## 토픽과 파티션 메트릭
* 클러스터의 트래픽을 많이 증가시키는 특정 토픽을 식별하기 위해 사용

### 토픽 메트릭
* 바이트 입력
* 바이트 출려 
* 읽기/쓰기 실패 요청 수
* 입력 메시지 수
* 전체 읽기/쓰기 요청 수

### 파티션 메트릭
* 파티션의 수가 너무 많은 경우가 많아 유용하게 사용하기 힘듬
* 다만 파티션 크기 메트릭 같은 경우 디스크에 저장된 데이터양을 나타내므로 카프카 비용을 계산하는데 사용 가능

---

## OS 모니터링
* 주로 살펴 보아야 할 것은 하드웨어 리소스 사용 정보

---

## 로깅 
* 적합은 로거를 적합한 레벨로 사용해야 함
* kafka.controller 로거는 클러스터 컨트롤러와 관련된(토픽 생성/변경, 브로커 상태 변경 등) 메시지를 제공

---

# 클라이언트 모니터링 

## 프로듀서 메트릭

### 전체 프로듀서 메트릭
* 메시지 배치의 크기부터 메모리 버퍼 사용에 이르기까지의 모든 것을 나타내는 속성들을 제공
* record-error-rate
  * 카프카 브로커에 메시지 전송을 시도하다가 실패하여 삭제한 것을 나타냄
  * 항상 0이어야 한다.
  * 프로듀서에 구성된 재시도횟수를 모두 사용했는데도 전송이 안 되면 해다 ㅇ메시지는 삭제된다.
* request-latency-avg
  * 브로커가 produce요청을 받을 때까지 소요된 평균 시간
  * 이 속성의 값이 증가한다는 것은 produce요청이 점점 느려진다는 것을 의미
* 프로듀서가 전송하는 메시지 트래픽이 얼마나 되는지 알수있는 메트릭이 있음
  * outgoing-byte-rate : 초당 입력되는 메시지의 절대 크기(byte)
  * record-send-rate : 초당 쓰는 메시지 개수
  * request-rate : 브로커에 전송되는 초당 produce 요청 수
* 메시지, 요청, 메시지 배치 크기를 나타내는 메트릭
  * request-size-avg : 브로커에게 전송되는 produce 요청의 평균 크기(byte) 
  * batch-size-avg : 한 메시지 배치의 평균 크기
  * record-size-avg : 한 레코드의 평균 크기
* record-queue-time-avg : 한 메시지 전송한 후 실제로 카프카에 쓰기 전에 해당 메시지가 프로듀서에서 대기하는 평균 시간

### 프로듀서-브로커 메트릭
* request-latency-avg : 특정 브로커와의 ㅇ녀결에 관한 문제점을 알 수 있음

---

## 컨슈머 메트릭

### Fetch 매니저 메트릭
* fetch 매니저 빈은 바이트, 요청, 레코드 읽기 속도에 관련도니 메트릭들을 갖는다.
* fetch-latency-avg
  * fetch 요청을 브로커가 받는 데 걸리는 시간을 알려줌
  * 지연을 제어하는 다른 옵션에 영향을 받지만 정기적으로 많은 메시지가 입력되는 토픽을 읽을때는 유용
* 컨슈머가 처리하는 메시지 트래픽과 관련된 메트릭
  * bytes-consumed-rate : 클라이언트 인스턴스가 읽는 초당 바이트
  * records-consumed-rate : 클라이언트 인스턴스가 읽는 초당 메시지 수
* fetch-rate : 컨슈머가 수행하는 초당 fetch 요청 수
* fetch-size-avg : fetch 요청의 평균 크기
* records-per-request-avg : fetch 요청의 평균 메시지 수

### 컨슈머 조정자 메트릭
* 컨슈머 조정자(coordinator)는 컨슈머 그룹 합류와 같은 일을 책임지고 처리함
* 조정자가 파티션을 조정할 때 읽기가 중지될 수 있음
* sync-time-avg 메트릭을 통해 조정 작업에 드는 평균 시간을 알 수 있음

---

## 쿼터
* 각 클라이언트의 초당 허용 트래픽과 같은 균형을 맞추기 위한 할당량이 있음
* 이러한 정보들의 메트릭을 제공함

---

# 지연 모니터링
* 프로듀서가 특정 파티션에 마지막으로 쓴 메시지와 컨슈머가 읽고 처리한 마지막 메시지 간의 차이