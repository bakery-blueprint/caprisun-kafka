# 카프카 관리 

### 카프카 토픽 네이밍 

두 개의 밑줄로 시작되는 토픽이름도 사용이 가능하지만 권장하지 않는다. 

카프카 내부적 internal 에서 사용하는 토픽을 의미한다. 

ex)'__consumer_offsets'

구두점도 권장하지 않는데, 카프카 내부이ㅡ 메트릭 네임이에서 구두점이 밑줄로 변경된다. 

ex) 'topic.1' -> 'topic_1'


- if--not-exists 를 붙여 토픽을 생성하면 중복 생성 에러를 방지할 수 있다. 


### 파티션 

파티션 개수를 줄일 수 없다. 토픽의 파티션을 삭제하면 토픽에 저장된 데이터도 삭제되기 때문이다. 

정말 원하면 토픽 자체를 삭제하고 다시 생성해야 한다. 


메시지의 키가 존재할 경우 파티션 추가가 어렵다. 

파티션 개수가 변경되면 키에 매핑되는 파티션이 달라져 컨슈머가 읽는 메시지의 순서가 바뀔수 있다. 


### 컨슈머 그룹 

그룹 정보는 구버전의 경우 주키퍼, 신버전에서는 카프카 브로커 내부에서 관리된다. 

- GROUP : 그룹의 이름
- TOPIC : 토픽 이름
- PARTITION : 파티션 ID
- CURRENT-OFFSET : 컨슈머 그룹에 의해 커밋된 토픽 파티션의 마지막 오프셋 
- LOG-END-OFFSET : 파티션에 저장된 데이터의 끝을 나타낸다. 파티션에 쓰고 클러스터에 커밋된 마지막 메시지의 오프셋 
- LAG : CURRENT-OFFSET 와 LOG-END-OFFSET의 차이를 나태낸다.
- OWNER : 현재 토픽 파티션을 소비하는 컨슈머 그룹의 멤버이다. 그룹 멤버에게 제공되는 임이의 ID이며 컨슈머의 호스트 이름은 포함하지 않는다. 


### 오프셋 관리 

그룹의 오프셋들을 조회하거나 삭제할뿐만 아니라 저장된 오프셋을 가져오거나 새로운 오프셋을 저장하는 것도 가능하다. 

이 기능은 컨슈머의 오프셋들을 재설정하는 데 유용하다. 

예를들어 메시지를 다시 ㅇ릭어야 하는 문제가 생겼을 때 또는 컨슈머의 문제가 있는 메시지 다음 오프셋으로 이동할 떄 이다. 


### 파티션 관리 

- 리더 파티션을 다시 선출 

- 브로커에게 파티션을 할당 


### 선호 리플리카 선출 

여러 리플리카를 가질 수 있지만, 그중 하나의 리플리카 브로커만이 파티션 리더가 될 수 있다.

모든 프로듀서와 컨슈머의 메시지 읽기 / 쓰기는 해당 파티션 리더 브로커를 통해서 수행된다.


### 파티션 리플리카 변경하기 

파티션의 리플리카 할당을 변경할 수 있다.

1. 토픽의 파티션들이 브로커들에게 고르게 배분되지 않을 경우 

2. 하나의 브로커가 오프라인일 때 

3. 새로운 브로커가 추가되어 클러스터의 작업량을 공유할 필요


- 하나의 브로커로부터 많은 파티션이 삭제 될때 브로커를 셧다운했다가 다시 시작시킨후 파티션 재할당하는게 좋다. 

브로커가 리더로 할당되었단 파티션들의 새로운 리더로 클러스터의 다른 브로커들이 지정된다. 






