# 메시지 발행과 구독하기
* 메시지 발행/구독 시스템에서는 데이터(메시지)를 발행자(전송자)가 직접 구독자(수신자)에게 보내지 않는다.
* 발행자가 어떤 형태로든 메시지를 구분해서 발행/구독 시스템에 전송
* 구독자가 특정 뷰류의 메시지를 구독할 수 있게 해줌
* 이때 발행된 메시지를 저장하고 중계하는 역할을 브로커가 수행한다.

## 초기의 발행/구독 시스템
* 초기 발행/구독 시스템은 간단한 메시지 큐나 프로세스 간 통신 채널을 갖는 형태로 시작된다.[책 그림 1-1]
* 만읾 메트릭을 생성하는 애플리케이션이 더 있다면 계속해서 연결이 늘어난다.
* 또한 메트릭 데이터를 제공하는 서버 또한 늘어난다. [책 그림 1-2]
* 개선이 필요한데, 모든 메트릭 데이터를 하나의 애플리캐이션이 수신하고 필요한 메트릭 데이터를 어떤 시스템에서도 쉽게 조회 할 수 있게 한다.[책 그림 1-3]

## 개별적인 메시지 큐 시스템
* 로그 메시지 및 추적 데이터를 제공해야할수도 있다.
* 데이터별로 발행자와 구독자를 분리할수도 있다 [책 그림 1-4]
* 그러나 여전히 많은 기능이 중복되고 다수의 메시지 처리 시스템을 유지/관리 해야한다.
* 또 다른 종류의 메시지를 처리하려면 새로운 시스템을 추가해야 한다.
* 따라서 일반환된 유형의 메시지 데이터를 발행/구독하는 하나의 집중 처리 시스템을 만들면 유연성이나 확장성이 좋아질 수 있다.

# 카프카 살펴보기
* 아파치 카프카는 최기의 발행/구독 시스템의 문제를 해결하기 위해 설계된 메시지 발행/구독 시스템이다.
* '분산 커밋 로그' 또는 '분산 스트리밍 플랫폼' 이라고도 한다.
* 카프카는 데이터를 지속해서 저장하고 읽을 수 있고, 장애에 대비하고 확장성에 따른 성능 저하를 방지하기 위해 분산 처리할 수있다.

## 메시지와 배치
* 카프카에서는 데이터의 기본 단위를 메시지라고 한다.
* 데이터베이스의 행이나 레코드에 비유될 수 있다.
* 카프카는 메시지를 바이트 배열의 데이터로 간주하므로 특정 형식이나 의미를 갖지 않는다.
* 키(Key)라는 메타데이터가 포함될 수 있으며, 이것 역시 바이트 배열이다.
* 카프카 메시지 데이터는 토픽(topic)으로 분류된 파티션(partition)에 수록
* 데이터를 수록할  때 파티션을 결정하기 위해 일관된 해시 값으로 키를 생성한다.
* 따라서 같은 키 값을 갖는 메시지는 항상 같은 파티션에 수록된다.
* 카프카는 효율성을 위해 여러 개의 메시지를 모아 배치(batch) 형태로 파티션에 수록
* 네트워크로부터 매번 각 메시지를 받아서 처리하는데 따른 부담을 줄일 수 있다.
* 물론 대기 시간(latency)과 처리량(throughput) 간의 트레이드오프가 있다.
* 배치에 압축 기술도 적용되어 효율적인 데이터 전송과 저장 능력을 제공

## 스키마
* 카프카 메시지는 내용을 이해하기 쉽도록 메시지의 구조를 나타내는 스키마를 사용할 수 있다.
* 표현 방법으로 JSON이나 XML을 사용한다.
* 또 하둡을 위해 개발된 Avro라는 직렬화 프레임워크를 선호하기도 한다.
* 카프카에서는 쓰기/읽기 작업이 분리되어 있어서 일관된 데이터 형식이 중요하다.
* 카프카에서는 잘 정의된 스키마를 공유 리포지터리에 젖아하여 사용할 수 있다.

## 토픽과 파티션
* 카프카의 메시지는 토픽(topic)으로 분류된다.
* 토픽은 데이터베이스의 테이블, 파일 시스템의 폴더와 유사하다.
* 하나의 토픽은 여러 개의 파티션(partition)으로 구성될 수 있다.
* 메시지는 파티션에 추가되는 형태로만 수록되며, FIFO 순서로 읽힌다.
* 하나의 토픽은 여러개의 파티션을 갖는다.
* 메시지 처리 순서는 토픽이 아닌 파티션별로 유지 관리된다. [책 그림 1-5]
* 하나의 토픽이 여러 서버에 걸쳐 수평적으로 확장될 수 있음을 의미
* 카프카에서 스트림이라는 용어는 파티션의 개수와 상관없이 하나의 토픽 데이터로 간주
* 데이터를 쓰는 프로듀서와 읽는 컨슈머로 이동되는 연속적인 데이터를 나타낸다.

## 프로듀서와 컨슈머

* 카프카의 클라이언트는 기본적으로 프로듀서와 컨슈머라는 두 가지 형태가 잇다.
* 또한 데이터 통합을 위한 카프카 커넥트 API, 스트림 처리를 위한 카프카 스트림즈의 클라이언트 API도 있다.
* **프로듀서**는 새로운 메시지를 생성
* 메시지는 특정 토픽으로 생성, 프로듀서는 일반적으로 메시지가 어떤 파티션에 수록되는지 관여하지 않는다.
* 때로는 메시지 키 & 파티셔너를 사용해서 특정 파티션에 쓸 수 있다.
* **컨슈머**는 메시지를 읽으며, 구독자 역할을 한다.
* 하나 이상의 토픽을 구독하여 메시지가 생성된 순서로 읽어, 메시지의 오프셋을 유지하여 읽는 메시지의 위치를 알 수 있다.
* 메타데이터인 오프셋은 지속적으로 증가하는 정수값이며, 메시지가 생성될 때 카프카가 추가해준다. 
* 주키퍼나 카프카에서는 각 파티션에서 마지막에 읽은 메시지의 오프셋을 저장하고 있음
* 메시지 읽기를 중단했다가 다시 읽더라도 그 다음 부터 메시지를 읽을 수 있음
* 컨슈머는 **컨슈머 그룹** 멤버로 동작
* 컨슈머는 하나 이상의 컨슈머로 구성되며, 한 토픽을 소비하기 위해 같은 그룹의 여러 컨슈머가 함께 동작한다.
* 한 토픽의 각 파티션은 하나의 컨슈머만 소비할 수 있다.[책 그림 1-6]
* 각 컨슈머가 특정 파티션에 대응되는 것을 파티션 소유권이라고 한다.
* 이 방법을 통해 컨슈머를 수평적으로 확장 할 수 있다.

## 브로커와 클러스터
* 하난의 카프카 서버를 브로커라고 한다.
* 프로듀서로부터 메시지를 수신하고 오프셋을 지정한 후 해당 메시지를 디스크에 젖아한다.
* 컨슈머의 파티션 읽기 요청에 응답하고 디스크에 수록된 메시지를 전송한다.
* 카프카의 브로커는 클러스터의 일부롣 동작한다.
* 그중 하나는 자동으로 선정되는 클러스터 컨트롤러의 기능을 수행한다.
* 컨트롤러는 같은 클러스터의 각 브로커에게 담당 파티션을 할당하고 정상동작하는지 모니터링을한다.
* 각 파티션은 한 클러스터의 한 브로커가 소유하며, 그 브로커를 파티션 리더라고 한다.
* 같은 파티션이 여러 브로커에 지정될 수도 있는데, 이때는 해당 파티션이 복제 된다.[책 그림 1-7]
* 메시지를 중복으로 저장해 장애에 대응할 수 있다.
* 카프카의 또다른 핵심기능은 일정 기간 메시지를 보존하는 것이다.
* 보존 메시지는 설정값(크기/기간)에 따라 달라진다.

## 다중 클러스터
* 카프카가 많이 설치되어 사용될 때 다중 클러스터를 고려하면 다음과 같은 장점이 있다.
  * 데이터 타입에 따라 구분해서 처리할 수 있음
  * 보안 요구사항을 분리해서 처리할 수 있음
  * 재해 복구를 대비한 다중 데이터센터를 유지할 수 있음

# 카프카를 사용하는 이유

## 다중 프로듀서 
* 여러 클라이언트가 많은 토픽을 사용하거나 같은 토픽을 같이 사용해도 무리없이 많은 프로듀서의 메시지를 처리할 수 있다.

## 다중 컨슈머
* 많은 컨슈머가 상호 간섭 없이 어떤 메시지 스트림도 읽을 수 있게 지원한다.
* 카프카 컨슈머는 컨슈머 그룹의 멤버가 되어 메시지 스트림을 공유한다.

## 디스크 기반의 보존
* 메시지를 보존할 수 있기 때문에 항상 실시간으로 컨슈머 애플리케이션이 실행되지 않아도 된다.
* 컨슈머 요구에 맞게 메시지 스트림마다 서로 다른 보존 옵션을 가질 수 있따.
* 처리가 느리거나 접속 폭주로 인해 컨슈머가 메시지를 읽는 데 실패하더라도 데이터가 유실될 위험이 없다.
* 컨슈머가 다시 실행되면 중단시점의 메시지부터 처리할 수 있다.

## 확장성
* 브로커의 수를 유동적으로 늘릴 수 있다.
* 확장 작업은 시스템 전체의 사용에 영향을 주지 않는다.
* 개별적 브로커 장애를 처리하면서 지속적인 서비스가 가능하다.

## 고성능

# 데이터 생태계
* 데이터를 처리하기 위해서는 여러 입력 / 처리 / 출력 형태가 존재하고 이러한 것들이 메시지 데이터 흐름을 구성한다.
* 카프카는 이러한 생태계 시스템을 제공한다.
* 일관된 인터페이스 제공
* 프로듀서와 컨슈머간 연관성 제거를 통한 자유로은 추가와 제거

## 이용 사례

### 활동 추적
* 웹 사이트 사용자 액션 추적을 위해 링크드인에서 사용
* 액션 데이터는 여러 곳에서 소비(머신 러닝, 검색, 리포트 생성 등)

### 메시지 전송
* 알림 메시지 전송에 유용
* 메시지 형식, 전송 방법을 신경 안써도 됨

### 메트릭과 로깅
* 메트릭을 카프카 토픽으로 저장 후 모니터링 / 보안 시스템에서 사용 가능

### 커밋 로그
* 변경 사항들을 메시지 스트림으로 생성
* 이 스트림 데이터는 변경 데이터를 복제하는데 사용 가능

### 스트림 프로세싱
* 스트림 프로세싱 지원